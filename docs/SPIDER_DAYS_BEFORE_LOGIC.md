# 爬虫 days_before 参数逻辑说明

## days_before=1 时的爬取逻辑

当定时任务设置 `days_before=1` 时，爬虫的爬取逻辑如下：

### 1. 时间范围计算

```python
today = datetime.now().date()  # 今天，例如：2025-12-24
earliest_date = today - timedelta(days=1)  # 昨天，例如：2025-12-23
```

**时间范围**：`earliest_date <= project_date <= today`
- 即：**昨天 00:00:00 至 今天 23:59:59** 的项目

### 2. 爬取流程

1. **遍历分类**（政府类 → 非政府类）
2. **遍历城市**（浙江省本级 → 杭州市 → 宁波市 → ... → 丽水市）
3. **对每个项目进行日期判断**：
   - ✅ **爬取**：如果项目日期在 `[昨天, 今天]` 范围内
   - ❌ **停止爬取该城市**：如果项目日期 < 昨天（太旧）
   - ⏭️ **跳过该项目**：如果项目日期 > 今天（未来日期）

### 3. 具体示例

假设今天是 **2025-12-24**，设置 `days_before=1`：

- **earliest_date** = 2025-12-23（昨天）
- **today** = 2025-12-24（今天）

**会爬取的项目**：
- ✅ 2025-12-23 的项目（昨天）
- ✅ 2025-12-24 的项目（今天）

**不会爬取的项目**：
- ❌ 2025-12-22 及更早的项目（停止该城市爬取）
- ❌ 2025-12-25 及以后的项目（跳过，未来日期）

### 4. 代码逻辑

```python
# 在 run() 方法中
if self.days_before is not None:
    earliest_date = today - timedelta(days=self.days_before)  # days_before=1时，earliest_date=昨天
    
    # 对每个项目：
    if project_date < earliest_date:
        # 项目日期早于昨天（太旧），停止该城市爬取
        log.info(f"发现项目日期（{project_date}）早于时间范围（{earliest_date}），停止该城市爬取")
        found_non_today = True
        break
    elif project_date > today:
        # 项目日期晚于今天（未来日期），跳过
        log.debug(f"发现未来日期项目（{project_date}），跳过")
        continue
    else:
        # earliest_date <= project_date <= today
        # 在范围内，继续爬取该项目
        # ... 保存项目
```

### 5. 日志输出示例

```
2025-12-24 00:00:00 | INFO | 开始爬取浙江省招标网，总配额: 300
2025-12-24 00:00:00 | INFO | 时间间隔限制：爬取最近 1 天内的文件
2025-12-24 00:00:00 | INFO | 时间范围：2025-12-23 至 2025-12-24（最近 1 天内）
2025-12-24 00:00:00 | INFO | 开始爬取[政府类]分类（110-978863）
2025-12-24 00:00:00 | INFO | [政府类]依次爬取各城市当日文件
2025-12-24 00:00:00 | INFO |   开始爬取城市: 浙江省本级（339900）的当日文件
...
2025-12-24 00:05:00 | INFO | [政府类-杭州市]发现项目日期（2025-12-22）早于时间范围（2025-12-23），停止该城市爬取
2025-12-24 00:05:00 | INFO |   [政府类-杭州市]城市当日文件爬取完成，实际获取: 5个
```

### 6. 不同 days_before 值的对比

| days_before | earliest_date | 爬取范围 | 说明 |
|------------|---------------|----------|------|
| `None` 或 `0` | - | 只爬取今天 | 默认行为 |
| `1` | 昨天 | 昨天 + 今天 | 最近1天 |
| `7` | 7天前 | 最近7天 | 最近一周 |
| `30` | 30天前 | 最近30天 | 最近一月 |

### 7. 注意事项

1. **日期判断基于项目的 `publish_time`**（发布时间），不是爬取时间
2. **按城市顺序爬取**，遇到超出时间范围的项目时，**停止该城市**的爬取，继续下一个城市
3. **达到配额限制时**，停止所有爬取
4. **时间范围是闭区间**：`[earliest_date, today]`，包含两端

### 8. 如果各个城市今天的文件都爬完后

当设置 `days_before=1` 时，如果各个城市今天的文件都爬完了，**会继续爬取昨天的文件**。

#### 8.1 爬取顺序

API返回的数据是按**时间倒序**排列的（最新的在前），所以：
1. **先遇到今天的项目**（2025-12-24）
2. **然后遇到昨天的项目**（2025-12-23）
3. **最后遇到更早的项目**（2025-12-22及更早）

#### 8.2 具体流程

假设今天是 **2025-12-24**，设置 `days_before=1`：

**场景1：某个城市今天有项目**
```
第1页：2025-12-24 项目1 ✅ 爬取
第1页：2025-12-24 项目2 ✅ 爬取
第1页：2025-12-24 项目3 ✅ 爬取
第2页：2025-12-24 项目4 ✅ 爬取
第2页：2025-12-23 项目5 ✅ 爬取（昨天的，继续）
第2页：2025-12-23 项目6 ✅ 爬取（昨天的，继续）
第3页：2025-12-23 项目7 ✅ 爬取（昨天的，继续）
第3页：2025-12-22 项目8 ❌ 停止（早于昨天，停止该城市）
```

**场景2：某个城市今天没有项目，只有昨天的项目**
```
第1页：2025-12-23 项目1 ✅ 爬取（昨天的，在范围内）
第1页：2025-12-23 项目2 ✅ 爬取（昨天的，继续）
第2页：2025-12-23 项目3 ✅ 爬取（昨天的，继续）
第2页：2025-12-22 项目4 ❌ 停止（早于昨天，停止该城市）
```

**场景3：某个城市今天和昨天都没有项目**
```
第1页：2025-12-22 项目1 ❌ 停止（早于昨天，立即停止该城市）
```

#### 8.3 停止条件

爬取会在以下情况停止：

1. **达到配额限制**：`total_count >= daily_limit`
2. **遇到超出时间范围的项目**：`project_date < earliest_date`（早于昨天）
3. **没有更多数据**：API返回空数据或达到最大页数
4. **所有城市都爬完**：遍历完所有城市

#### 8.4 关键代码逻辑

```python
# 循环条件：继续爬取直到遇到超出范围的项目或达到配额
while page_no <= max_pages and not found_non_today and total_count < daily_limit:
    # 处理每个项目
    if project_date < earliest_date:
        # 项目日期早于昨天（太旧），停止该城市爬取
        found_non_today = True
        break
    elif project_date > today:
        # 未来日期，跳过该项目
        continue
    else:
        # 在范围内（昨天或今天），继续爬取
        # 保存项目...
```

#### 8.5 总结

- ✅ **会继续爬取昨天的文件**：只要项目日期在 `[昨天, 今天]` 范围内
- ✅ **按页顺序爬取**：先爬今天的，再爬昨天的
- ❌ **不会爬取更早的文件**：遇到早于昨天的项目时，停止该城市
- ✅ **继续下一个城市**：一个城市停止后，继续下一个城市

### 9. 应用场景

- **days_before=1**：适用于每天定时任务，确保不遗漏昨天和今天的项目
- **days_before=7**：适用于每周汇总，爬取一周内的项目
- **days_before=30**：适用于月度汇总，爬取一个月内的项目

---

**最后更新时间**：2025-12-24

